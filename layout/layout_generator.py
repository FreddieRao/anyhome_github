import json
import re
import regex
import numpy as np
import openai

from termcolor import colored
from layout.placement_rules import *
from layout.utils import *


class LayoutGenerator:
    def __init__(self, description, house_v, house_f, border_map_no_doors, room_name_dict, boxes, centers):
        self.description = description
        self.house_v = house_v
        self.house_f = house_f
        self.border_map_no_doors = border_map_no_doors
        self.room_name_dict = room_name_dict
        self.boxes = boxes
        self.centers = centers
        self.str_to_rule = {  # Dict to map the string generated by LLMs to the placement rule functions
            "place_wall": place_wall,
            "place_beside": place_beside,
            "place_center": place_center,
            "place_front": place_front,
            "place_around": place_around,
            "place_corner": place_corner,
            "place_ceiling": place_ceiling,
            "place_next_wall": place_next_wall,
            "place_next": place_next,
            # "place_top": place_top,
            # "place_on_wall": place_on_wall,
        }
    
    def generate_room_objects(self, edit=False):
        furniture_graph_list, ornament_graph_list = {}, {}  # Store the room graphs for each room
        poss, sizs, angs = [], [], []  # Store the positions, sizes, and angles of the objects
        for i, room in enumerate(list(self.room_name_dict.keys())):
            print(colored(f"Generating objects for {room}...", "grey"))
            # Obtain the room area
            box = self.boxes[i]  # Obtain the bounding boxes for this room
            areas = [(x2-x1) * (y2-y1) for (x1, y1, x2, y2) in box]
            total_area = sum(areas)

            # Generate the furniture diagram and layout
            furniture_graph = self.generate_furniture_diagram(total_area, room)
            furniture_graph_list[room] = furniture_graph
            pos, siz, ang = self.generate_furniture_layout(i, room, furniture_graph)

            while edit:  # Allow multiple-round language-guided editing
                edit_description = input(colored("Enter the description of the changes you want to make to the layout graph (Enter q to stop editing): ", "green"))
                if edit_description == "q" or edit_description == "":
                    break
                furniture_graph = self.generate_furniture_diagram(total_area, room, is_edit=True, edit_description=edit_description, edit_graph=furniture_graph)
                furniture_graph_list[room] = furniture_graph
                pos, siz, ang = self.generate_furniture_layout(i, room, furniture_graph)

            poss.append(pos)
            sizs.append(siz)
            angs.append(ang)

            # Generate the ornament diagram
            ornament_graph = self.generate_ornament_diagram(total_area, room, list(pos.keys()))
            ornament_graph_list[room] = ornament_graph

            while edit:
                edit_description = input(colored("Enter the description of the changes you want to make to the layout graph (Enter q to stop editing): ", "green"))
                if edit_description == "q" or edit_description == "":
                    break
                ornament_graph = self.generate_ornament_diagram(total_area, room, list(pos.keys()), is_edit=True, edit_description=edit_description, edit_graph=ornament_graph)
                ornament_graph_list[room] = ornament_graph

    def generate_furniture_layout(self, i, room, room_graph):
        # Place the furniture in the room
        mask = (self.border_map_no_doors == i).astype(int)  # Create a dummy mask for the room
        mask[self.border_map_no_doors == -1] = -1
        maskk = mask.copy()
        modi_sizes = {}
        for k, v in room_graph["furniture_sizes"].items():
            modi_sizes[k] = [v[0], v[1]]
        pos, siz, ang = self.place_furnitures_auto(room_graph["furniture_groups_and_placement_rules"], modi_sizes, self.boxes[i], self.centers[i], mask)  # extract the furniture's bounding boxes
        visualize_room_plan(pos, siz, ang, maskk)
        print(colored(f"{room} Layout Specifications", "yellow"))
        print(colored("positions: ", "blue") + str(pos) + colored("\nsizes: ", "blue") + str(siz) + colored("\nangles:", "blue") + str(ang))

        return pos, siz, ang
    
    def generate_furniture_diagram(self, room_area, room_type, is_edit=False, edit_description=None, edit_graph=None):
        # Generate a graph from description using GPT-4
        context_msg = """
        Task: You are an awesome 3D Scene Designer. Design a 3D indoor scene for a {} located within a {}. Ensure that the design fits within an area of {} square meters. Provide the details as a scene graph, structured in a JSON format.

        Requirements:
        1. Furniture List:
            - Enumerate the furniture in the {}. If an item appears multiple times, append an index. Remember that the furniture should be suitable for a {} and maintain the style of the house. For example, you shouldn't only generate two sets of tables and chairs for an office room.
            - Use only from this predefined list: children_cabinet, nightstand, bookcase, wardrobe, coffee_table, corner_table, side_cabinet, wine_cabinet, tv_stand, drawer_chest, shelf, round_end_table, double_bed, queen_bed, king_bed, bunk_bed, bed_frame, single_bed, kids_bed, dining_chair, lounge_chair, office_chair, dressing_chair, classic_chinese_chair, barstool, dressing_table, dining_table, desk, three_seat_sofa, armchair, loveseat_sofa, l_shaped_sofa, lazy_sofa, chaise_longue_sofa, stool, kitchen_cabinet, toilet, bathtub, sink.
            - You need to generate as many furnitures as you can.
            - Example: If there are two lazy sofas and an armchair in the room, list them as: “[lazy_sofa1, lazy_sofa2, armchair1]”.
        2. Furniture Description:
            - For each furniture, provide a description of its aesthetic shape and structure considering the house and room's styles.
            - Example: "A wood-carved three-seated sofa with two armrests at the sides."
            - Return format: {{<furniture_name>: <description>}}
        3. Furniture Size:
            - For each furniture, provide its dimensions (length, width, height) in meters, even if the dimensions repeat with other furnitures, keeping in mind the {} square meters room area.
            - Return format: {{<furniture_name>: [length(meters), width(meters), height(meters)]}}
        4. Furniture Groups & Placement Rules:
            - Separate the furniture into groups that will exist together in the scene, such as a bed and two nightstands. For those furniture that is unrelated with each other, put them in different groups. Put the important furniture groups at first when returning your answer. For example, put the funiture group containing the kitchen cabinet at first in a kitchen, and that containing the sofa, tv stand and coffee table at first in a living room.
            - For each group, you should determine only one anchor furniture. For example, the anchor for a bed and two nightstands is the bed.
            - Then, you should decide on the placement rule for this anchor furniture. You can use only the following anchor rules:
                (1) "place_center" which places the anchor furniture at the center of the room
                (2) "place_next_wall" which places the anchor with its side against a segment of the wall, useful for rooms with rows and columns of furniture like a classroom
                (3) "place_wall" which places the anchor with its back against a segment of the wall
                (4) "place_corner" which places the anchor at a corner
                (5) “place_next(another_anchor_name, x)” which places the anchor furniture beside another anchor specified in the parameter with a buffer distance of x meters. The "another_anchor_name" is the another anchor's name in the furniture list.
            - Last, for the other non-anchor furnitures in the group, you can only use the following non-anchor rules:
                (1) "place_front(x)" which places the furniture in front of the anchor with a buffer distance of x meters, like a TV stand before a coffee table, 
                (2) "place_beside(x)" which places the furniture beside the anchor with a buffer distance of x meters, like a nightstand beside a bed
                (3) "place_around(x)" which places the furniture around the anchor with a buffer distance of x meters, like placing four chairs around a dining table.
            - You can set x to 0 if you want the furniture to be placed right next to the anchor.
            - CAUTIOUS: Anchor furnitures can only use the anchor rules, while non-anchor furnitures can only use the non-anchor rules. For example, DO NOT use "place_next(another_anchor_name, x)" for non-anchor furnitures, use "place_beside(x) instead".
            - Return format: [[[<anchor_furniture_name>, <anchor_placement_rule>], [<non-anchor_furniture_name>, <non-anchor_placement_rule>], [<non-anchor_furniture_name>, <non-anchor_placement_rule>], ...], ...]

        Output: Provide the information in a valid JSON structure with no spaces. I'll give you 100 bucks if you help me design a perfect scene and return it in the right format:
        {{
            "furniture_list": [...],
            "furniture_descriptions": {{...}},
            "furniture_sizes": {{...}},
            "furniture_groups_and_placement_rules": [...]
        }}
        """
        context_msg = context_msg.format(room_type, self.description, room_area, room_type, room_type, room_area)
        
        edit_context_msg = """
        Task: You are an awesome 3D Scene Designer serving a customer. You are given a 3D indoor scene graph for a {} located within a {}. The design fits within an area of {} square meters. The scene graph is generated with the four requirements below:

        Requirements:
        1. Furniture List:
            - Enumerate the furniture in the {}. If an item appears multiple times, append an index. Remember that the furniture should be suitable for a {} and maintain the style of the house. For example, you shouldn't only generate two sets of tables and chairs for an office room.
            - Use only from this predefined list: children_cabinet, nightstand, bookcase, wardrobe, coffee_table, corner_table, side_cabinet, wine_cabinet, tv_stand, drawer_chest, shelf, round_end_table, double_bed, queen_bed, king_bed, bunk_bed, bed_frame, single_bed, kids_bed, dining_chair, lounge_chair, office_chair, dressing_chair, classic_chinese_chair, barstool, dressing_table, dining_table, desk, three_seat_sofa, armchair, loveseat_sofa, l_shaped_sofa, lazy_sofa, chaise_longue_sofa, stool, kitchen_cabinet, toilet, bathtub, sink.
            - You need to generate as many furnitures as you can.
            - Example: If there are two lazy sofas and an armchair in the room, list them as: “[lazy_sofa1, lazy_sofa2, armchair1]”.
        2. Furniture Description:
            - For each furniture, provide a description of its aesthetic shape and structure considering the house and room's styles.
            - Example: "A wood-carved three-seated sofa with two armrests at the sides."
            - Return format: {{<furniture_name>: <description>}}
        3. Furniture Size:
            - For each furniture, provide its dimensions (length, width, height) in meters, even if the dimensions repeat with other furnitures, keeping in mind the {} square meters room area.
            - Return format: {{<furniture_name>: [length(meters), width(meters), height(meters)]}}
        4. Furniture Groups & Placement Rules:
            - Separate the furniture into groups that will exist together in the scene, such as a bed and two nightstands. For those furniture that is unrelated with each other, put them in different groups. Put the important furniture groups at first when returning your answer. For example, put the funiture group containing the kitchen cabinet at first in a kitchen, and that containing the sofa, tv stand and coffee table at first in a living room.
            - For each group, you should determine only one anchor furniture. For example, the anchor for a bed and two nightstands is the bed.
            - Then, you should decide on the placement rule for this anchor furniture. You can use only the following anchor rules:
                (1) "place_center" which places the anchor furniture at the center of the room
                (2) "place_next_wall" which places the anchor with its side against a segment of the wall, useful for rooms with rows and columns of furniture like a classroom
                (3) "place_wall" which places the anchor with its back against a segment of the wall
                (4) "place_corner" which places the anchor at a corner
                (5) “place_next(another_anchor_name, x)” which places the anchor furniture beside another anchor specified in the parameter with a buffer distance of x meters. The "another_anchor_name" is the another anchor's name in the furniture list.
            - Last, for the other non-anchor furnitures in the group, you can only use the following non-anchor rules:
                (1) "place_front(x)" which places the furniture in front of the anchor with a buffer distance of x meters, like a TV stand before a coffee table, 
                (2) "place_beside(x)" which places the furniture beside the anchor with a buffer distance of x meters, like a nightstand beside a bed
                (3) "place_around(x)" which places the furniture around the anchor with a buffer distance of x meters, like placing four chairs around a dining table.
            - You can set x to 0 if you want the furniture to be placed right next to the anchor.
            - CAUTIOUS: Anchor furnitures can only use the anchor rules, while non-anchor furnitures can only use the non-anchor rules. For example, DO NOT use "place_next(another_anchor_name, x)" for non-anchor furnitures, use "place_beside(x) instead".
            - Return format: [[[<anchor_furniture_name>, <anchor_placement_rule>], [<non-anchor_furniture_name>, <non-anchor_placement_rule>], [<non-anchor_furniture_name>, <non-anchor_placement_rule>], ...], ...]

        Generated Data of the Scene Graph of the {}:
        {}

        Now, the customer wants to edit the scene graph. They have provided the following description of the changes they want to make:
        {}

        Task: Could you please update the floorplan based on the customer's request and provide the updated data strictly following the same requirements above? If the customer's request collides with the requirement above, followed the requirements above. For example, if the customer wants to use "place_around(x)" as the placement rule for an anchor furniture, you should not follow it and generate the placement rule based on the requirements above.

        Output: Provide the information in a valid JSON structure with no spaces. I'll give you 100 bucks if you help me design a perfect scene and return it in the right format:
        {{
            "furniture_list": [...],
            "furniture_descriptions": {{...}},
            "furniture_sizes": {{...}},
            "furniture_groups_and_placement_rules": [...]
        }}
        """
        edit_context_msg = edit_context_msg.format(room_type, self.description, room_area, room_type, room_type, room_area, room_type, edit_graph, edit_description)

        client = openai.OpenAI()
        raw_response = client.chat.completions.create(
            model="gpt-4",
            messages=[
                {"role": "user", "content": context_msg if not is_edit else edit_context_msg},
            ],
            temperature=0.4,
            max_tokens=4096
        )
        response_str = raw_response.choices[0].message.content
        raw_response = response_str.replace("\n", "").strip()
        pattern = r'\{(?:[^{}]|(?R))*\}'
        response = json.loads(regex.search(pattern, raw_response).group())

        print(colored(f"{room_type} Furniture Graph", "yellow"))
        print('\n'.join([f'{colored(k, "blue")}: {v}' for k, v in response.items()]))

        return response

    def place_furnitures_auto(self, furniture_groups_and_placement_rules, furniture_sizes, bbox, centers, collision_map):
        """The main function to iteratively place the furniture groups in the room, using the rules above"""
        def place_spare():
            indices = np.argwhere(collision_map == 1)
            key_x, key_y = np.mean(indices, axis=0)
            key_x, key_y = int(round(float(key_x), 0)), int(round(float(key_y), 0))
            # the orientation would be somewaht facing the nearest door
            door_locs = np.argwhere(collision_map == -1)  # indicate the door locations
            distance = lambda p1, p2: abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])
            nearest_door = min(door_locs, key=lambda door_loc: distance([key_x, key_y], list(door_loc)))
            if nearest_door[0] > key_x and nearest_door[1] > key_y:
                key_ang = random.choice(["E", "N"])
            elif nearest_door[0] > key_x and nearest_door[1] < key_y:
                key_ang = random.choice(["E", "S"])
            elif nearest_door[0] < key_x and nearest_door[1] > key_y:
                key_ang = random.choice(["W", "N"])
            else:
                key_ang = random.choice(["W", "S"])

            return key_x, key_y, key_ang

        furniture_pos, furniture_siz, furniture_ang = {}, {}, {}

        center_num = 0
        for group in furniture_groups_and_placement_rules:
            anchor, anchor_rule = group[0]
            key_siz = [int(furniture_sizes[anchor][0] * 12), int(furniture_sizes[anchor][1] * 12)]
            if anchor_rule == "place_center":  # if two furnitures are to be placed centerly, then place the subsequent one at the center of last available spaces
                key_x, key_y, key_ang = place_spare() if center_num > 0  else place_center(bbox, centers, key_siz, collision_map)
            elif anchor_rule[:11] == "place_next(":  # if place_next is used, the parameters are different
                # Extracting another_anchor and buffer using regex
                anchor_rule_matches = re.findall(r"\((.*?),\s*(.*?)\)", anchor_rule)
                another_anchor, buffer = anchor_rule_matches[0]
                if another_anchor not in furniture_pos.keys():  # if the anchor is not placed
                    key_x, key_y, key_ang = None, None, None
                else:  # if the another anchor is placed, place the current anchor next to it
                    key_x, key_y, key_ang = place_next(key_siz, furniture_pos[another_anchor], furniture_siz[another_anchor], furniture_ang[another_anchor], int(float(buffer) * 6), collision_map)
            else:  # else, place it according to the rule
                anchor_func = self.str_to_rule[anchor_rule]
                key_x, key_y, key_ang = anchor_func(bbox, centers, key_siz, collision_map)

            if key_x is None:  # if the anchor cannot be placed due to conflicts
                key_x, key_y, key_ang = place_spare() if anchor_rule[:11] != "place_next(" else place_next_wall(bbox, centers, key_siz, collision_map)

            if key_ang == "W" or key_ang == "E":  # rotation 90 deg
                key_siz = key_siz[::-1]

            if not is_valid_position(key_x, key_y, key_siz[0], key_siz[1], collision_map):  # if not a valid placement, skip this group
                print(colored(f"No space for {anchor} in the room", "grey"))
                continue

            key_pos = [key_x, key_y]
            collision_map[key_x:key_x+key_siz[0]+1, key_y:key_y+key_siz[1]+1] = 255  # indicating that the furniture is place
            furniture_pos[anchor], furniture_siz[anchor], furniture_ang[anchor] = key_pos, key_siz, key_ang  # update the list

            for furniture, furniture_rule_str in group[1:]:
                if furniture_rule_str.split("(")[0] not in ["place_front", "place_beside", "place_around"]:  # sometimes the llm generates anchor rules for non-anchor furnitures
                    print(colored(f"Invalid placement rule for {furniture}", "grey"))
                    continue

                furniture_rule = self.str_to_rule[furniture_rule_str.split("(")[0]]
                matches = re.findall(r"\(([0-9]*\.?[0-9]+)\)", furniture_rule_str)
                furniture_rule_buffer = int(float(matches[0]) * 6)
                siz = [int(furniture_sizes[furniture][0] * 12), int(furniture_sizes[furniture][1] * 12)]
                x, y, ang = furniture_rule(siz, key_pos, key_siz, key_ang, furniture_rule_buffer, collision_map)
                if x is None:
                    print(colored("No space for {} in the room".format(furniture), "grey"))
                    continue

                if ang == "W" or ang == "E":  # rotation
                    siz = siz[::-1]
                collision_map[x:x+siz[0]+1, y:y+siz[1]+1] = 255
                furniture_pos[furniture], furniture_siz[furniture], furniture_ang[furniture] = [x, y], siz, ang

        return furniture_pos, furniture_siz, furniture_ang
    
    def generate_ornament_diagram(self, room_area, room_type, room_furnitures, is_edit=False, edit_description=None, edit_graph=None):
        # Generate a graph from description using GPT-4
        context_msg = """
        Task: You are an awesome 3D Scene Designer. Design the ornaments added to an existing {} located within a {} that has an area of {} square meters. These are the furnitures in the room right now: {}.
        
        Requirements:
        1. Ornament List:
            - Enumerate all the ornaments in this room. Any objects beside children_cabinet, nightstand, bookcase, wardrobe, coffee_table, corner_table, side_cabinet, wine_cabinet, tv_stand, drawer_chest, shelf, round_end_table, double_bed, queen_bed, king_bed, bunk_bed, bed_frame, single_bed, kids_bed, dining_chair, lounge_chair, office_chair, dressing_chair, classic_chinese_chair, barstool, dressing_table, dining_table, desk, three_seat_sofa, armchair, loveseat_sofa, l_shaped_sofa, lazy_sofa, chaise_longue_sofa, stool, kitchen_cabinet, toilet, bathtub, and sink are considered ornaments.
            - You can generate any ornament. Examples might include a Spongebob statue, a witch's hat, and a Gothic clock. 
            - Please take into consideration the area and style of the room when you are generating.
            - Generate as many ornaments as you can, and be CREATIVE with the ornaments; any weird ornaments are welcome.
            - Return format: [<ornament1>, <ornament2>, ...]
        2. Ornament Descriptions:
            - For each ornament, provide a description of its aesthetic shape and structure considering the house and room's styles.
            - Example: "A classic witch hat, made of black velvet with a wide brim."
            - Return format: {{<ornament_name>: <description>}}
        3. Ornament Sizes:
            - For each ornament, provide its dimensions (length, width, and height) in meters, keeping in mind the <room_area> square meters room area.
            - Return format: {{<ornament_name>: [length(meters), width(meters), height(meters)]}}
        4. Ornament Placements: 
            - For each ornament, provide its placement rule in the scene; below are the rules that you can use:
                (1) "place_center" which places the ornament at the center of available spaces in the room,
                (2) "place_next_wall" which places the ornament with its side against a segment of the wall.
                (3) "place_wall" which places the ornament with its back against a segment of the wall
                (4) "place_corner" which places the ornament at a corner
                (5) "place_front(x, anchor)" which places the ornament in front of an existing anchor furniture in the given list above with a buffer distance of x meters, like placing a mirror in front of a cabinet.
                (6) "place_beside(x, anchor)" which places the furniture beside an existing anchor furniture in the given list above with a buffer distance of x meters, like placing a vase beside a TV stand.
                (7) "place_around(x, anchor)" which places the furniture around an existing anchor furniture in the given list above with a buffer distance of x meters, like placing a set of candelabras around a dining table.
                (8) "place_top(x, anchor)" which places the ornament on top of an existing anchor furniture in the given list above with a buffer distance of x meters, like placing a vodka bottle on a table.
                (9) "place_on_wall(x)" which places the ornament on the wall at a height of x meters, like placing a clock on the wall.
            - For example, if a pear is placed 1 meter beside "table1", your response should be {{"pear", "place_beside(1, table1)”}}.
            - You can set x to 0 if you want the buffer distance to 0.
            - Return format: {{<ornament_name>: <placement_rule>}}

        Output: Provide the information in a valid JSON structure with no spaces. I'll give you 100 bucks if you help me design a perfect scene and return it in the right format:
        {{
            "ornament_list": [...],
            "ornament_descriptions": {{...}},
            "ornament_sizes": {{...}},
            "ornament_placements": [...]
        }}
        """
        context_msg = context_msg.format(room_type, self.description, room_area, str(room_furnitures))

        edit_context_msg = """
        Task: You are an awesome 3D Scene Designer serving a customer. You are given a 3D indoor ornament graph for a {} located within a {}. The design fits within an area of {} square meters. The ornament graph is a complement to the existing furnitures in the room, and these furnitures are {}. The scene graph is generated with the four requirements below:

        Requirements:
        1. Ornament List:
            - Enumerate all the ornaments in this room. Any objects beside children_cabinet, nightstand, bookcase, wardrobe, coffee_table, corner_table, side_cabinet, wine_cabinet, tv_stand, drawer_chest, shelf, round_end_table, double_bed, queen_bed, king_bed, bunk_bed, bed_frame, single_bed, kids_bed, dining_chair, lounge_chair, office_chair, dressing_chair, classic_chinese_chair, barstool, dressing_table, dining_table, desk, three_seat_sofa, armchair, loveseat_sofa, l_shaped_sofa, lazy_sofa, chaise_longue_sofa, stool, kitchen_cabinet, toilet, bathtub, and sink are considered ornaments.
            - You can generate any ornament. Examples might include a Spongebob statue, a witch's hat, and a Gothic clock. 
            - Please take into consideration the area and style of the room when you are generating.
            - Generate as many ornaments as you can, and be CREATIVE with the ornaments; any weird ornaments are welcome.
            - Return format: [<ornament1>, <ornament2>, ...]
        2. Ornament Descriptions:
            - For each ornament, provide a description of its aesthetic shape and structure considering the house and room's styles.
            - Example: "A classic witch hat, made of black velvet with a wide brim."
            - Return format: {{<ornament_name>: <description>}}
        3. Ornament Sizes:
            - For each ornament, provide its dimensions (length, width, and height) in meters, keeping in mind the <room_area> square meters room area.
            - Return format: {{<ornament_name>: [length(meters), width(meters), height(meters)]}}
        4. Ornament Placements: 
            - For each ornament, provide its placement rule in the scene; below are the rules that you can use:
                (1) "place_center" which places the ornament at the center of available spaces in the room,
                (2) "place_next_wall" which places the ornament with its side against a segment of the wall.
                (3) "place_wall" which places the ornament with its back against a segment of the wall
                (4) "place_corner" which places the ornament at a corner
                (5) "place_front(x, anchor)" which places the ornament in front of an existing anchor furniture in the given list above with a buffer distance of x meters, like placing a mirror in front of a cabinet.
                (6) "place_beside(x, anchor)" which places the furniture beside an existing anchor furniture in the given list above with a buffer distance of x meters, like placing a vase beside a TV stand.
                (7) "place_around(x, anchor)" which places the furniture around an existing anchor furniture in the given list above with a buffer distance of x meters, like placing a set of candelabras around a dining table.
                (8) "place_top(x, anchor)" which places the ornament on top of an existing anchor furniture in the given list above with a buffer distance of x meters, like placing a vodka bottle on a table.
                (9) "place_on_wall(x)" which places the ornament on the wall at a height of x meters, like placing a clock on the wall.
            - For example, if a pear is placed 1 meter beside "table1", your response should be {{"pear", "place_beside(1, table1)”}}.
            - You can set x to 0 if you want the buffer distance to 0.
            - Return format: {{<ornament_name>: <placement_rule>}}

        Generated Data of the Scene Graph of the {}:
        {}

        Now, the customer wants to edit the scene graph. They have provided the following description of the changes they want to make:
        {}

        Task: Could you please update the ornament graph based on the customer's request and provide the updated data strictly following the same requirements above?

        Output: Provide the information in a valid JSON structure with no spaces. I'll give you 100 bucks if you help me design a perfect ornament graph and return it in the right format:
        {{
            "ornament_list": [...],
            "ornament_descriptions": {{...}},
            "ornament_sizes": {{...}},
            "ornament_placements": [...]
        }}
        """
        edit_context_msg = edit_context_msg.format(room_type, self.description, room_area, str(room_furnitures), room_type, edit_graph, edit_description)

        client = openai.OpenAI()
        raw_response = client.chat.completions.create(
            model="gpt-4",
            messages=[
                {"role": "user", "content": context_msg if not is_edit else edit_context_msg},
            ],
            temperature=0.4,
            max_tokens=4096
        )
        response_str = raw_response.choices[0].message.content
        raw_response = response_str.replace("\n", "").strip()
        pattern = r'\{(?:[^{}]|(?R))*\}'
        response = json.loads(regex.search(pattern, raw_response).group())

        print(colored(f"{room_type} Ornament Graph", "yellow"))
        print('\n'.join([f'{colored(k, "blue")}: {v}' for k, v in response.items()]))

        return response
